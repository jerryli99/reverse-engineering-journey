This is just some notes about the methods to do object copying and cloning in c++. 

1. Default Copy Constructor (shallow copy)

generated by the compiler if no custom copy logic is defined.

performs member-wise shallow copy (dangerous for pointers)

class MyClass {
public:
    int* data;
    MyClass(int val) : data(new int(val)) {}
    ~MyClass() {delete data;}
};

void demo() {
    MyClass obj1(42);
    MyClass obj2 = obj1; //default copy constructor here (shallow copy)
    //both obj1.data and obj2.data point to the same memory.
}

2. Custom Copy constructor (Deep Copy)

Explicitly defined to avoid shallow copy pitfalls.

Required for class managing resources (e.g. dynamic memory)

class MyClass {
public:
    int* data;
    MyClass(int val) : data(new int(val)) {}
    
    // Custom copy constructor (DEEP COPY)
    MyClass(const MyClass& other) : data(new int(*other.data)) {}
    
    ~MyClass() { delete data; }
};

void demo() {
    MyClass obj1(42);
    MyClass obj2 = obj1; // Deep copy: obj2.data is a new allocation
}

3. Copy assignment operator(operator=)

Handles assignment betwen existing objects

Must check for self-assignment and perform deep copy

class MyClass {
public:
    int* data;
    MyClass(int val) : data(new int(val)) {}
    
    // Custom copy assignment
    MyClass& operator=(const MyClass& other) {
        if (this != &other) { // Self-assignment check
            *data = *other.data; // Or reallocate for deep copy
        }
        return *this;
    }
    
    ~MyClass() { delete data; }
};

void demo() {
    MyClass obj1(42), obj2(0);
    obj2 = obj1; // Uses operator=
}

4. Clone Method (Polymorphic Copy)
Virtual function to enable polymorphic cloning.

Requires a base class with a virtual destructor.

class Base {
public:
    virtual ~Base() = default;
    virtual Base* clone() const = 0; // Pure virtual clone
};

class Derived : public Base {
public:
    int* data;
    Derived(int val) : data(new int(val)) {}
    
    Derived* clone() const override { // Covariant return type
        return new Derived(*this); // Uses copy constructor
    }
    
    ~Derived() { delete data; }
};

void demo() {
    Base* original = new Derived(42);
    Base* copy = original->clone(); // Polymorphic clone
    delete original;
    delete copy;
}


5. Move Constructor (T(T&&)) and Move Assignment (operator=(T&&))

Transfers ownership of resources (e.g., dynamic memory) efficiently.

Part of C++11's move semantics.

class MyClass {
public:
    int* data;
    MyClass(int val) : data(new int(val)) {}
    
    // Move constructor
    MyClass(MyClass&& other) noexcept : data(other.data) {
        other.data = nullptr; // Steal resource
    }
    
    // Move assignment
    MyClass& operator=(MyClass&& other) noexcept {
        if (this != &other) {
            delete data;       // Free existing resource
            data = other.data; // Steal resource
            other.data = nullptr;
        }
        return *this;
    }
    
    ~MyClass() { delete data; }
};

void demo() {
    MyClass obj1(42);
    MyClass obj2 = std::move(obj1); // Move constructor (obj1.data is now nullptr)
}


6. std::unique_ptr for Exclusive Ownership

No copying allowed (deleted copy constructor/assignment).

Supports move semantics.

#include <memory>
class Resource { /*...*/ };

void demo() {
    std::unique_ptr<Resource> ptr1 = std::make_unique<Resource>();
    // std::unique_ptr<Resource> ptr2 = ptr1; // Error: Copy disabled
    std::unique_ptr<Resource> ptr2 = std::move(ptr1); // OK: Move
}

7. std::shared_ptr for Shared Ownership

Reference-counted copying.

All copies share ownership.

#include <memory>
class Resource { /*...*/ };

void demo() {
    std::shared_ptr<Resource> ptr1 = std::make_shared<Resource>();
    std::shared_ptr<Resource> ptr2 = ptr1; // OK: Shared ownership
}


8. Serialization-Based Copy (e.g., JSON, Protocol Buffers)

Convert object to a byte stream, then reconstruct.

Useful for deep copies across process boundaries.

#include <nlohmann/json.hpp>
using json = nlohmann::json;

struct Person {
    std::string name;
    int age;
    
    json serialize() const {
        return {{"name", name}, {"age", age}};
    }
    
    static Person deserialize(const json& j) {
        return {j["name"], j["age"]};
    }
};

void demo() {
    Person alice{"Alice", 30};
    json j = alice.serialize();
    Person copy = Person::deserialize(j); // Deep copy via serialization
}


Summary Table
Method	                    Use Case	                             Key Feature
Default Copy Constructor	Simple objects (no pointers/resources)	 Shallow copy (dangerous for pointers)
Custom Copy Constructor	    Classes with dynamic memory	             Deep copy
Copy Assignment Operator	Assigning existing objects	             Deep copy with self-assignment check
Clone Method	            Polymorphic hierarchies	                 Virtual clone() function
Move Constructor/Assignment	Efficient resource transfer	             Steals resources (no copy)
std::unique_ptr	            Exclusive ownership	                     Copy disabled, move-only
std::shared_ptr	            Shared ownership	                     Reference-counted copying
Serialization	            Cross-process or persistent copies	     Deep copy via byte streams
When to Use Which?
Deep Copy: Mandatory for classes managing resources (e.g., raw pointers).

Move Semantics: Optimize performance for temporary objects.

Smart Pointers: Prefer over raw pointers for automatic memory management.

Clone Method: Needed in polymorphic class hierarchies.

Serialization: For complex object graphs or IPC scenarios.

Choose the method based on your object's lifetime, ownership semantics, and performance requirements.