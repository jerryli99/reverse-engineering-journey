OK, where can we start then? Hummm, well, I only know some C and C++ and some Python and very little assembly. 

(Note: as time progresses, these stages might change or not...)

So far, I will use Ghidra to do the reverse engineering since it is free.

### Stage 1:

Let's start with something simple, like data types (including type casting stuff), if/else, and loops for programs in a single file or/and with some statically linked libs.

Then do pointers, structs, union, enum for programs in a single file.

Then write larger programs with memory allocation type of stuff and do the reverse engineering.

Need to write detailed explanation how I think and show the "why" part if possible in a timely manner. Hopefully I can even finish this.


### Stage 2: 

Once I feel more comfortable, then start writing C++ classes. Start with references, pointers, creating new objects.

Then encapsulation, inheritance, polymorphism.

Then virual functions?

Then ....

Well, so far, just be familiar of the assembly syntax.


### Stage 3:

Start writing programs that use data structures (linked lists, lists, queue, stack, trees, graphs) and threads. See the assembly, and then try to make sense of it. 

Start mixing data structures and threads. See how they work.

I think this stage is becoming hardcore.


### Stage 4: (mixing with Stage 3 if possible)

Start writing common item searching algorithms, sorting algorithms, etc., and write detailed reports.

Start writing more complex algorithms and try my best to explain them from the reversed assembly code.

Now we are beginning to see progress.


### Stage 5: 

Start hunting our target programs in the wild....


Stage 6: ????